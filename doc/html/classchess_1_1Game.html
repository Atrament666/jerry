<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Jerry - Chess GUI: chess::Game Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Jerry - Chess GUI
   &#160;<span id="projectnumber">3</span>
   </div>
   <div id="projectbrief">Jerry is a Chess GUI, usable with any UCI engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>chess</b></li><li class="navelem"><a class="el" href="classchess_1_1Game.html">Game</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classchess_1_1Game-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">chess::Game Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adca9940d7473dcac562c2934d0e762a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adca9940d7473dcac562c2934d0e762a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#adca9940d7473dcac562c2934d0e762a9">Game</a> ()</td></tr>
<tr class="memdesc:adca9940d7473dcac562c2934d0e762a9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classchess_1_1Game.html">Game</a> essentially a tree of <a class="el" href="classchess_1_1GameNode.html">GameNode</a> objects that represents a game. Default root node has a board position which is empty. <br/></td></tr>
<tr class="separator:adca9940d7473dcac562c2934d0e762a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8425c271f2d8365f813e5e169f7d1ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchess_1_1GameNode.html">GameNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#ac8425c271f2d8365f813e5e169f7d1ed">getRootNode</a> ()</td></tr>
<tr class="memdesc:ac8425c271f2d8365f813e5e169f7d1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">getRootNode returns the root node of the game  <a href="#ac8425c271f2d8365f813e5e169f7d1ed">More...</a><br/></td></tr>
<tr class="separator:ac8425c271f2d8365f813e5e169f7d1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77233d7bfe997d113300b3c4333258d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchess_1_1GameNode.html">GameNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#a77233d7bfe997d113300b3c4333258d4">getCurrentNode</a> ()</td></tr>
<tr class="memdesc:a77233d7bfe997d113300b3c4333258d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">getCurrentNode returns the current node. The current node is a pointer to a node in the tree and used e.g. for the node of the last move  <a href="#a77233d7bfe997d113300b3c4333258d4">More...</a><br/></td></tr>
<tr class="separator:a77233d7bfe997d113300b3c4333258d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae095f72d044192f348c1f0b740aae32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#aae095f72d044192f348c1f0b740aae32">getResult</a> ()</td></tr>
<tr class="memdesc:aae095f72d044192f348c1f0b740aae32"><td class="mdescLeft">&#160;</td><td class="mdescRight">getResult returns the result of the game  <a href="#aae095f72d044192f348c1f0b740aae32">More...</a><br/></td></tr>
<tr class="separator:aae095f72d044192f348c1f0b740aae32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b10980b3b16b19c73e07034840ea3ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#a9b10980b3b16b19c73e07034840ea3ea">setResult</a> (int r)</td></tr>
<tr class="memdesc:a9b10980b3b16b19c73e07034840ea3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">setResult sets the result of the game  <a href="#a9b10980b3b16b19c73e07034840ea3ea">More...</a><br/></td></tr>
<tr class="separator:a9b10980b3b16b19c73e07034840ea3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5346e8f2b6d5063c2e1c8f892a08ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#a5a5346e8f2b6d5063c2e1c8f892a08ed">applyMove</a> (<a class="el" href="classchess_1_1Move.html">Move</a> *m)</td></tr>
<tr class="memdesc:a5a5346e8f2b6d5063c2e1c8f892a08ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">applyMove apply a move to the current node, and change the node to the resulting new node (or existing node) if a child node for this move already exists. There is no check if the supplied move is legal!  <a href="#a5a5346e8f2b6d5063c2e1c8f892a08ed">More...</a><br/></td></tr>
<tr class="separator:a5a5346e8f2b6d5063c2e1c8f892a08ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac018e45f806510247404ba56feda568c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchess_1_1GameNode.html">GameNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#ac018e45f806510247404ba56feda568c">findNodeById</a> (int id)</td></tr>
<tr class="memdesc:ac018e45f806510247404ba56feda568c"><td class="mdescLeft">&#160;</td><td class="mdescRight">findNodeById each <a class="el" href="classchess_1_1GameNode.html">GameNode</a> has a unique id (see class definition) this searches for and find the node given the supplied id throw std::invalid_argument if there exists no node with the id  <a href="#ac018e45f806510247404ba56feda568c">More...</a><br/></td></tr>
<tr class="separator:ac018e45f806510247404ba56feda568c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07156dfe4b3dff8991350dcb38c9508e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#a07156dfe4b3dff8991350dcb38c9508e">setCurrent</a> (<a class="el" href="classchess_1_1GameNode.html">GameNode</a> *new_current)</td></tr>
<tr class="memdesc:a07156dfe4b3dff8991350dcb38c9508e"><td class="mdescLeft">&#160;</td><td class="mdescRight">setCurrent set the current pointer to the supplied node. There is no validity check whether the node is actually a node in the game tree.  <a href="#a07156dfe4b3dff8991350dcb38c9508e">More...</a><br/></td></tr>
<tr class="separator:a07156dfe4b3dff8991350dcb38c9508e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af508607bc605b8974c2a393f0b3ecae1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#af508607bc605b8974c2a393f0b3ecae1">setRoot</a> (<a class="el" href="classchess_1_1GameNode.html">GameNode</a> *new_root)</td></tr>
<tr class="memdesc:af508607bc605b8974c2a393f0b3ecae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">setRoot sets the root node pointer to the supplied node. Really just that. Beware of memory leaks when using this function, as nodes below the old root might become inaccessible  <a href="#af508607bc605b8974c2a393f0b3ecae1">More...</a><br/></td></tr>
<tr class="separator:af508607bc605b8974c2a393f0b3ecae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254acf6e5423d9f9332f6f43f0455cb7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a254acf6e5423d9f9332f6f43f0455cb7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#a254acf6e5423d9f9332f6f43f0455cb7">goToMainLineChild</a> ()</td></tr>
<tr class="memdesc:a254acf6e5423d9f9332f6f43f0455cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">goToMainLineChild moves the current node pointer one down to the mainline (zeroth) variation (if it exists), otherwise keeps the pointer at the current node <br/></td></tr>
<tr class="separator:a254acf6e5423d9f9332f6f43f0455cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b634132c4549290bd1bedd2444f7072"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#a6b634132c4549290bd1bedd2444f7072">goToChild</a> (int idx_child)</td></tr>
<tr class="memdesc:a6b634132c4549290bd1bedd2444f7072"><td class="mdescLeft">&#160;</td><td class="mdescRight">goToChild moves the current node poiner to the child at index idx_child. If the index is out of range, keeps the pointer at the current node.  <a href="#a6b634132c4549290bd1bedd2444f7072">More...</a><br/></td></tr>
<tr class="separator:a6b634132c4549290bd1bedd2444f7072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192a5708f9cc181ceff6bfd0eb2fc883"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a192a5708f9cc181ceff6bfd0eb2fc883"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#a192a5708f9cc181ceff6bfd0eb2fc883">goToParent</a> ()</td></tr>
<tr class="memdesc:a192a5708f9cc181ceff6bfd0eb2fc883"><td class="mdescLeft">&#160;</td><td class="mdescRight">goToParent moves current node pointer to the parent node (if exists). keeps pointer at existing node if already at root <br/></td></tr>
<tr class="separator:a192a5708f9cc181ceff6bfd0eb2fc883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14b8365fc4c0a472b00a214fd67e302"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa14b8365fc4c0a472b00a214fd67e302"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#aa14b8365fc4c0a472b00a214fd67e302">goToRoot</a> ()</td></tr>
<tr class="memdesc:aa14b8365fc4c0a472b00a214fd67e302"><td class="mdescLeft">&#160;</td><td class="mdescRight">goToRoot moves current pointer to the root node of the game <br/></td></tr>
<tr class="separator:aa14b8365fc4c0a472b00a214fd67e302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad421efa010dedf785ad2c6211910167f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad421efa010dedf785ad2c6211910167f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#ad421efa010dedf785ad2c6211910167f">goToEnd</a> ()</td></tr>
<tr class="memdesc:ad421efa010dedf785ad2c6211910167f"><td class="mdescLeft">&#160;</td><td class="mdescRight">goToEnd starting at the current node, moves the current node pointer down among all mainline until reaching a leaf <br/></td></tr>
<tr class="separator:ad421efa010dedf785ad2c6211910167f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5232c5b68052202aa8167df619837912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#a5232c5b68052202aa8167df619837912">moveUp</a> (<a class="el" href="classchess_1_1GameNode.html">GameNode</a> *node)</td></tr>
<tr class="memdesc:a5232c5b68052202aa8167df619837912"><td class="mdescLeft">&#160;</td><td class="mdescRight">moveUp Suppose the supplied node is a child referenced at parent with index i, and there is another child of the parent with index i-1. Then this function switches these indexes. In other word, moves the supplied node variation one up. Has no effect, if node is root (i.e. has no parent) or is already the mainline (i.e. the zeroth) child of parent.  <a href="#a5232c5b68052202aa8167df619837912">More...</a><br/></td></tr>
<tr class="separator:a5232c5b68052202aa8167df619837912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c87b025f3d1aceaded403d62c40f567"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#a0c87b025f3d1aceaded403d62c40f567">moveDown</a> (<a class="el" href="classchess_1_1GameNode.html">GameNode</a> *node)</td></tr>
<tr class="memdesc:a0c87b025f3d1aceaded403d62c40f567"><td class="mdescLeft">&#160;</td><td class="mdescRight">moveDown Reverse of <a class="el" href="classchess_1_1Game.html#a5232c5b68052202aa8167df619837912" title="moveUp Suppose the supplied node is a child referenced at parent with index i, and there is another c...">moveUp()</a>.  <a href="#a0c87b025f3d1aceaded403d62c40f567">More...</a><br/></td></tr>
<tr class="separator:a0c87b025f3d1aceaded403d62c40f567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca844dd847f3e163e9da9e990f30931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#aaca844dd847f3e163e9da9e990f30931">delVariant</a> (<a class="el" href="classchess_1_1GameNode.html">GameNode</a> *node)</td></tr>
<tr class="memdesc:aaca844dd847f3e163e9da9e990f30931"><td class="mdescLeft">&#160;</td><td class="mdescRight">delVariant deletes the whole variation on which the supplied node exists. I.e. moves up the tree to the root of the variation, and deletes everything below. sets current node pointer to the root of the variation.  <a href="#aaca844dd847f3e163e9da9e990f30931">More...</a><br/></td></tr>
<tr class="separator:aaca844dd847f3e163e9da9e990f30931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb049584b03af5ce0d58f5feb6806a1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#afb049584b03af5ce0d58f5feb6806a1f">delBelow</a> (<a class="el" href="classchess_1_1GameNode.html">GameNode</a> *node)</td></tr>
<tr class="memdesc:afb049584b03af5ce0d58f5feb6806a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">delBelow delete the subtree below the supplied node. Afterwards sets current node pointer to the supplied node.  <a href="#afb049584b03af5ce0d58f5feb6806a1f">More...</a><br/></td></tr>
<tr class="separator:afb049584b03af5ce0d58f5feb6806a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9da8af7684660ec3880f15143e051b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#acb9da8af7684660ec3880f15143e051b">removeCommentRec</a> (<a class="el" href="classchess_1_1GameNode.html">GameNode</a> *node)</td></tr>
<tr class="memdesc:acb9da8af7684660ec3880f15143e051b"><td class="mdescLeft">&#160;</td><td class="mdescRight">removeCommentRec removes comment at supplied node and recursively removes at all comments at nodes below the supplied node.  <a href="#acb9da8af7684660ec3880f15143e051b">More...</a><br/></td></tr>
<tr class="separator:acb9da8af7684660ec3880f15143e051b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f62be6e55d2e3415f5e08016e9c038"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37f62be6e55d2e3415f5e08016e9c038"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#a37f62be6e55d2e3415f5e08016e9c038">goToLeaf</a> ()</td></tr>
<tr class="memdesc:a37f62be6e55d2e3415f5e08016e9c038"><td class="mdescLeft">&#160;</td><td class="mdescRight">goToLeaf from the current node pointer, go down the mainlines until there are no more childs. <br/></td></tr>
<tr class="separator:a37f62be6e55d2e3415f5e08016e9c038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d450a354b5943cca2a60380f5152b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#ae7d450a354b5943cca2a60380f5152b4">resetWithNewRootBoard</a> (<a class="el" href="classchess_1_1Board.html">chess::Board</a> *new_root_board)</td></tr>
<tr class="memdesc:ae7d450a354b5943cca2a60380f5152b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">resetWithNewRootBoard delete the whole game tree, and set a new root node constructed with the supplied move. Essentially call this, if a new game has been requrested by the user, especially if the user has set up a custom board position. The supplied board MUST be a valid board position.  <a href="#ae7d450a354b5943cca2a60380f5152b4">More...</a><br/></td></tr>
<tr class="separator:ae7d450a354b5943cca2a60380f5152b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ab6e0fd6ee734a9810886f57e87b5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18ab6e0fd6ee734a9810886f57e87b5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#a18ab6e0fd6ee734a9810886f57e87b5a">removeAllComments</a> ()</td></tr>
<tr class="memdesc:a18ab6e0fd6ee734a9810886f57e87b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">removeAllComments iterates through the tree, and removes every comment from each <a class="el" href="classchess_1_1GameNode.html">GameNode</a> <br/></td></tr>
<tr class="separator:a18ab6e0fd6ee734a9810886f57e87b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bad886ab7d0041ae777afa84667dca3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bad886ab7d0041ae777afa84667dca3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#a0bad886ab7d0041ae777afa84667dca3">removeAllVariants</a> ()</td></tr>
<tr class="memdesc:a0bad886ab7d0041ae777afa84667dca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">removeAllVariants iterates through the tree and keeps only the mainlines (i.e. zeroth) variations if there are more than one child in a <a class="el" href="classchess_1_1GameNode.html">GameNode</a> <br/></td></tr>
<tr class="separator:a0bad886ab7d0041ae777afa84667dca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa39fec09e0c6aa13b0c03e7ce1dbc44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa39fec09e0c6aa13b0c03e7ce1dbc44"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#afa39fec09e0c6aa13b0c03e7ce1dbc44">clearHeaders</a> ()</td></tr>
<tr class="memdesc:afa39fec09e0c6aa13b0c03e7ce1dbc44"><td class="mdescLeft">&#160;</td><td class="mdescRight">clearHeaders deletes all headers entries. <br/></td></tr>
<tr class="separator:afa39fec09e0c6aa13b0c03e7ce1dbc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a80169885e34540646a724431673067e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80169885e34540646a724431673067e5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#a80169885e34540646a724431673067e5">treeWasChanged</a></td></tr>
<tr class="memdesc:a80169885e34540646a724431673067e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">treeWasChanged this variable is set to true (either by a member function of <a class="el" href="classchess_1_1Game.html">Game</a> or manually) if an operation was carried out that changed fundamentally the tree structure In other words, if the this variable is true, an existing GUI representation of the <a class="el" href="classchess_1_1Game.html">Game</a> tree must be likely be reconstructed <br/></td></tr>
<tr class="separator:a80169885e34540646a724431673067e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c48e9e2ec4e304baf425dc9ab493b17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c48e9e2ec4e304baf425dc9ab493b17"></a>
QMap&lt; QString, QString &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Game.html#a6c48e9e2ec4e304baf425dc9ab493b17">headers</a></td></tr>
<tr class="memdesc:a6c48e9e2ec4e304baf425dc9ab493b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">headers contains the game headers. During construction of a <a class="el" href="classchess_1_1Game.html">Game</a> object there will always be the 7tag roster index entries (albeit initialized to empty field) <br/></td></tr>
<tr class="separator:a6c48e9e2ec4e304baf425dc9ab493b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5a5346e8f2b6d5063c2e1c8f892a08ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Game::applyMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchess_1_1Move.html">Move</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>applyMove apply a move to the current node, and change the node to the resulting new node (or existing node) if a child node for this move already exists. There is no check if the supplied move is legal! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the move to apply on the current board. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb049584b03af5ce0d58f5feb6806a1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Game::delBelow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchess_1_1GameNode.html">GameNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>delBelow delete the subtree below the supplied node. Afterwards sets current node pointer to the supplied node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaca844dd847f3e163e9da9e990f30931"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Game::delVariant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchess_1_1GameNode.html">GameNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>delVariant deletes the whole variation on which the supplied node exists. I.e. moves up the tree to the root of the variation, and deletes everything below. sets current node pointer to the root of the variation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac018e45f806510247404ba56feda568c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchess_1_1GameNode.html">GameNode</a> * chess::Game::findNodeById </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>findNodeById each <a class="el" href="classchess_1_1GameNode.html">GameNode</a> has a unique id (see class definition) this searches for and find the node given the supplied id throw std::invalid_argument if there exists no node with the id </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the node id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gamenode with the supplied id </dd></dl>

</div>
</div>
<a class="anchor" id="a77233d7bfe997d113300b3c4333258d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchess_1_1GameNode.html">GameNode</a> * chess::Game::getCurrentNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getCurrentNode returns the current node. The current node is a pointer to a node in the tree and used e.g. for the node of the last move </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aae095f72d044192f348c1f0b740aae32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chess::Game::getResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getResult returns the result of the game </p>
<dl class="section return"><dt>Returns</dt><dd>RES_BLACK_WINS or RES_DRAW or RES_WHITE_WINS or RES_UNDEF </dd></dl>

</div>
</div>
<a class="anchor" id="ac8425c271f2d8365f813e5e169f7d1ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchess_1_1GameNode.html">GameNode</a> * chess::Game::getRootNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getRootNode returns the root node of the game </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a6b634132c4549290bd1bedd2444f7072"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Game::goToChild </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx_child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>goToChild moves the current node poiner to the child at index idx_child. If the index is out of range, keeps the pointer at the current node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx_child</td><td>the index of the variation of the child node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c87b025f3d1aceaded403d62c40f567"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Game::moveDown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchess_1_1GameNode.html">GameNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>moveDown Reverse of <a class="el" href="classchess_1_1Game.html#a5232c5b68052202aa8167df619837912" title="moveUp Suppose the supplied node is a child referenced at parent with index i, and there is another c...">moveUp()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5232c5b68052202aa8167df619837912"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Game::moveUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchess_1_1GameNode.html">GameNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>moveUp Suppose the supplied node is a child referenced at parent with index i, and there is another child of the parent with index i-1. Then this function switches these indexes. In other word, moves the supplied node variation one up. Has no effect, if node is root (i.e. has no parent) or is already the mainline (i.e. the zeroth) child of parent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node that should be moved up </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb9da8af7684660ec3880f15143e051b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Game::removeCommentRec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchess_1_1GameNode.html">GameNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removeCommentRec removes comment at supplied node and recursively removes at all comments at nodes below the supplied node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to start with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7d450a354b5943cca2a60380f5152b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Game::resetWithNewRootBoard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchess_1_1Board.html">chess::Board</a> *&#160;</td>
          <td class="paramname"><em>new_root_board</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>resetWithNewRootBoard delete the whole game tree, and set a new root node constructed with the supplied move. Essentially call this, if a new game has been requrested by the user, especially if the user has set up a custom board position. The supplied board MUST be a valid board position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_root_board</td><td>The chess board to construct the root node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07156dfe4b3dff8991350dcb38c9508e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Game::setCurrent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchess_1_1GameNode.html">GameNode</a> *&#160;</td>
          <td class="paramname"><em>new_current</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>setCurrent set the current pointer to the supplied node. There is no validity check whether the node is actually a node in the game tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_current</td><td>pointer to the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b10980b3b16b19c73e07034840ea3ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Game::setResult </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>setResult sets the result of the game </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>see <a class="el" href="classchess_1_1Game.html#aae095f72d044192f348c1f0b740aae32" title="getResult returns the result of the game ">getResult()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af508607bc605b8974c2a393f0b3ecae1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Game::setRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchess_1_1GameNode.html">GameNode</a> *&#160;</td>
          <td class="paramname"><em>new_root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>setRoot sets the root node pointer to the supplied node. Really just that. Beware of memory leaks when using this function, as nodes below the old root might become inaccessible </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_root</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>chess/<a class="el" href="game_8h_source.html">game.h</a></li>
<li>chess/game.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat May 21 2016 22:33:28 for Jerry - Chess GUI by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>

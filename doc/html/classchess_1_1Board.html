<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Jerry - Chess GUI: chess::Board Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Jerry - Chess GUI
   &#160;<span id="projectnumber">3</span>
   </div>
   <div id="projectbrief">Jerry is a Chess GUI, usable with any UCI engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>chess</b></li><li class="navelem"><a class="el" href="classchess_1_1Board.html">Board</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classchess_1_1Board-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">chess::Board Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa18fed833d071775910da2cebd65ccef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa18fed833d071775910da2cebd65ccef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#aa18fed833d071775910da2cebd65ccef">Board</a> ()</td></tr>
<tr class="memdesc:aa18fed833d071775910da2cebd65ccef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classchess_1_1Board.html">Board</a> creates empty board, no castling rights. <br/></td></tr>
<tr class="separator:aa18fed833d071775910da2cebd65ccef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af172f8f4202f976b9e08a602f7f7e104"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#af172f8f4202f976b9e08a602f7f7e104">Board</a> (bool initial_position)</td></tr>
<tr class="memdesc:af172f8f4202f976b9e08a602f7f7e104"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classchess_1_1Board.html">Board</a> creates board w/ initial position, castling rights set if called with true creates empty board board, no castling rights if called with false.  <a href="#af172f8f4202f976b9e08a602f7f7e104">More...</a><br/></td></tr>
<tr class="separator:af172f8f4202f976b9e08a602f7f7e104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147c213c864ad018056ca446e2de46b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a147c213c864ad018056ca446e2de46b7">Board</a> (const QString &amp;fen_string)</td></tr>
<tr class="memdesc:a147c213c864ad018056ca446e2de46b7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classchess_1_1Board.html">Board</a>.  <a href="#a147c213c864ad018056ca446e2de46b7">More...</a><br/></td></tr>
<tr class="separator:a147c213c864ad018056ca446e2de46b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98009c374d8ca3778124a2618ef1b36b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a98009c374d8ca3778124a2618ef1b36b">Board</a> (<a class="el" href="classchess_1_1Board.html">Board</a> *board)</td></tr>
<tr class="memdesc:a98009c374d8ca3778124a2618ef1b36b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classchess_1_1Board.html">Board</a> creates new <a class="el" href="classchess_1_1Board.html">Board</a> copying position of the pieces of the supplied board. Parameters (i.e. undo history, move numbers etc. are <em>not</em> copied, just the position of the pieces.  <a href="#a98009c374d8ca3778124a2618ef1b36b">More...</a><br/></td></tr>
<tr class="separator:a98009c374d8ca3778124a2618ef1b36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf162aeb9ab6abbb3e4d6a868e3a07e7"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#acf162aeb9ab6abbb3e4d6a868e3a07e7">fen</a> ()</td></tr>
<tr class="memdesc:acf162aeb9ab6abbb3e4d6a868e3a07e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">fen returns FEN string of current board  <a href="#acf162aeb9ab6abbb3e4d6a868e3a07e7">More...</a><br/></td></tr>
<tr class="separator:acf162aeb9ab6abbb3e4d6a868e3a07e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff07e23bb49d912617caf276323443e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchess_1_1Board.html">Board</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#afff07e23bb49d912617caf276323443e">copy_and_apply</a> (const <a class="el" href="classchess_1_1Move.html">Move</a> &amp;m)</td></tr>
<tr class="memdesc:afff07e23bb49d912617caf276323443e"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy_and_apply applies move and returns a deep copy of current board no check of legality. always call board.is_legal(m) before applying move  <a href="#afff07e23bb49d912617caf276323443e">More...</a><br/></td></tr>
<tr class="separator:afff07e23bb49d912617caf276323443e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d17441690ffdf9a1000309e2272f6de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a5d17441690ffdf9a1000309e2272f6de">apply</a> (const <a class="el" href="classchess_1_1Move.html">Move</a> &amp;m)</td></tr>
<tr class="memdesc:a5d17441690ffdf9a1000309e2272f6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply applies supplied move. doesn't check for legality no check of legality. always call board.is_legal(m) before applying move  <a href="#a5d17441690ffdf9a1000309e2272f6de">More...</a><br/></td></tr>
<tr class="separator:a5d17441690ffdf9a1000309e2272f6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd72bf71259ba08016f6b547075d19b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbd72bf71259ba08016f6b547075d19b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#afbd72bf71259ba08016f6b547075d19b">undo</a> ()</td></tr>
<tr class="memdesc:afbd72bf71259ba08016f6b547075d19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">undo undoes the very last move. undoing can only be done once for the very last move that was applied before, i.e. apply undo apply undo is ok, but apply apply undo undo is not. throws logic error if called in wrong fashion. check with <a class="el" href="classchess_1_1Board.html#a0c19f4ee4fed148786b1215790f62a0e" title="is_undo_available checks whether the current board position has enough information to apply the undo(...">is_undo_available()</a> when in doubt <br/></td></tr>
<tr class="separator:afbd72bf71259ba08016f6b547075d19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9aa7f45517551baa208ed49ede59d97"><td class="memItemLeft" align="right" valign="top">Moves *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#ac9aa7f45517551baa208ed49ede59d97">pseudo_legal_moves</a> ()</td></tr>
<tr class="memdesc:ac9aa7f45517551baa208ed49ede59d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo_legal_moves returns move list with all pseudo-legal moves of current position  <a href="#ac9aa7f45517551baa208ed49ede59d97">More...</a><br/></td></tr>
<tr class="separator:ac9aa7f45517551baa208ed49ede59d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d573f32784dd7744640a5709c44de50"><td class="memItemLeft" align="right" valign="top">Moves *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a9d573f32784dd7744640a5709c44de50">pseudo_legal_moves_from</a> (int from_square_idx, bool with_castles, bool turn_color)</td></tr>
<tr class="memdesc:a9d573f32784dd7744640a5709c44de50"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo_legal_moves_from returns move list with pseudo legal moves from supplied square index  <a href="#a9d573f32784dd7744640a5709c44de50">More...</a><br/></td></tr>
<tr class="separator:a9d573f32784dd7744640a5709c44de50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33abea2f6fba7df0e683fa1198a8520"><td class="memItemLeft" align="right" valign="top">Moves *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#af33abea2f6fba7df0e683fa1198a8520">legal_moves</a> ()</td></tr>
<tr class="memdesc:af33abea2f6fba7df0e683fa1198a8520"><td class="mdescLeft">&#160;</td><td class="mdescRight">legal_moves returns move list of all legal moves in position  <a href="#af33abea2f6fba7df0e683fa1198a8520">More...</a><br/></td></tr>
<tr class="separator:af33abea2f6fba7df0e683fa1198a8520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354b83ee53ba1f0ff7a7d0bac148d758"><td class="memItemLeft" align="right" valign="top">Moves *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a354b83ee53ba1f0ff7a7d0bac148d758">legal_moves_from</a> (int from_square)</td></tr>
<tr class="memdesc:a354b83ee53ba1f0ff7a7d0bac148d758"><td class="mdescLeft">&#160;</td><td class="mdescRight">legal_moves_from computes all legal moves originating in from square  <a href="#a354b83ee53ba1f0ff7a7d0bac148d758">More...</a><br/></td></tr>
<tr class="separator:a354b83ee53ba1f0ff7a7d0bac148d758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804f9b6cceeef5f3f5d866d16e1097a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a804f9b6cceeef5f3f5d866d16e1097a2">pseudo_is_legal_move</a> (const <a class="el" href="classchess_1_1Move.html">Move</a> &amp;)</td></tr>
<tr class="memdesc:a804f9b6cceeef5f3f5d866d16e1097a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo_is_legal_move checks whether supplied pseudo legal move is legal in current position. Does NOT check whether supplied move is pseudo legal!!!  <a href="#a804f9b6cceeef5f3f5d866d16e1097a2">More...</a><br/></td></tr>
<tr class="separator:a804f9b6cceeef5f3f5d866d16e1097a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8243ca7cdd3fa72f07aa5f225a750a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#acd8243ca7cdd3fa72f07aa5f225a750a">is_legal_move</a> (const <a class="el" href="classchess_1_1Move.html">Move</a> &amp;)</td></tr>
<tr class="memdesc:acd8243ca7cdd3fa72f07aa5f225a750a"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_legal_move checks whether the supplied move is legal in the board position. Always call before applying a move on a board!  <a href="#acd8243ca7cdd3fa72f07aa5f225a750a">More...</a><br/></td></tr>
<tr class="separator:acd8243ca7cdd3fa72f07aa5f225a750a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae338726c0c954644b99342c9760d5924"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#ae338726c0c954644b99342c9760d5924">is_legal_and_promotes</a> (const <a class="el" href="classchess_1_1Move.html">Move</a> &amp;)</td></tr>
<tr class="memdesc:ae338726c0c954644b99342c9760d5924"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_legal_and_promotes checks whether supplied move is legal and is a pawn move promoting to another piece  <a href="#ae338726c0c954644b99342c9760d5924">More...</a><br/></td></tr>
<tr class="separator:ae338726c0c954644b99342c9760d5924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12b1804d1edf018dbb348055cf88025"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#af12b1804d1edf018dbb348055cf88025">is_check</a> ()</td></tr>
<tr class="memdesc:af12b1804d1edf018dbb348055cf88025"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_check checks if the player whose on the move in the current position is in check  <a href="#af12b1804d1edf018dbb348055cf88025">More...</a><br/></td></tr>
<tr class="separator:af12b1804d1edf018dbb348055cf88025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24673c511d27445702013a7569f7291b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a24673c511d27445702013a7569f7291b">is_checkmate</a> ()</td></tr>
<tr class="memdesc:a24673c511d27445702013a7569f7291b"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_checkmate tests whether player who is on the move in current position is in checkmate (i.e. is in check but has not legal move escaping the check)  <a href="#a24673c511d27445702013a7569f7291b">More...</a><br/></td></tr>
<tr class="separator:a24673c511d27445702013a7569f7291b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff751702f53df82a8af55d66f187f66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a7ff751702f53df82a8af55d66f187f66">is_stalemate</a> ()</td></tr>
<tr class="memdesc:a7ff751702f53df82a8af55d66f187f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_stalemate tests whether player who is on the move in current position is in stalemate (i.e. is not in check but all legal moves would result in check)  <a href="#a7ff751702f53df82a8af55d66f187f66">More...</a><br/></td></tr>
<tr class="separator:a7ff751702f53df82a8af55d66f187f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c498a11b0432a8c41a9dcece41612b7"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a2c498a11b0432a8c41a9dcece41612b7">san</a> (const <a class="el" href="classchess_1_1Move.html">Move</a> &amp;m)</td></tr>
<tr class="memdesc:a2c498a11b0432a8c41a9dcece41612b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">san computes the standard algebraic notation for the supplied move given the current position. the supplied move MUST be legal on this board  <a href="#a2c498a11b0432a8c41a9dcece41612b7">More...</a><br/></td></tr>
<tr class="separator:a2c498a11b0432a8c41a9dcece41612b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872aeef9bac835b88393092229685410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchess_1_1Move.html">Move</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a872aeef9bac835b88393092229685410">parse_san</a> (QString s)</td></tr>
<tr class="memdesc:a872aeef9bac835b88393092229685410"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse_san Given board position and san string, parses the san string and computes a move for it. Throws std::invalid_argument if the supplied san string cannot be parsed successfully (i.e. illegal move, illegal formatted string etc.)  <a href="#a872aeef9bac835b88393092229685410">More...</a><br/></td></tr>
<tr class="separator:a872aeef9bac835b88393092229685410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422f4f975a7946ad593e870aa46cec89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a422f4f975a7946ad593e870aa46cec89">movePromotes</a> (const <a class="el" href="classchess_1_1Move.html">Move</a> &amp;m)</td></tr>
<tr class="memdesc:a422f4f975a7946ad593e870aa46cec89"><td class="mdescLeft">&#160;</td><td class="mdescRight">movePromotes checks if the supplied move (ignoring the promotion value stored in the move is a pawn move to the 8th / 1st rank, i.e. promoting)  <a href="#a422f4f975a7946ad593e870aa46cec89">More...</a><br/></td></tr>
<tr class="separator:a422f4f975a7946ad593e870aa46cec89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20f52e22fd1f61458f523eb6c1e9c7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#af20f52e22fd1f61458f523eb6c1e9c7b">is_initial_position</a> ()</td></tr>
<tr class="memdesc:af20f52e22fd1f61458f523eb6c1e9c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_initial_position checks whether the current placement of the pieces corresponds to the inital chess position.  <a href="#af20f52e22fd1f61458f523eb6c1e9c7b">More...</a><br/></td></tr>
<tr class="separator:af20f52e22fd1f61458f523eb6c1e9c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e8eecec4bae12a4018228fbb94ff1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a89e8eecec4bae12a4018228fbb94ff1c">can_castle_wking</a> ()</td></tr>
<tr class="memdesc:a89e8eecec4bae12a4018228fbb94ff1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">can_castle_wking checks whether the castling rights for the position are such that the White king is allowed to castle kingside in this position.  <a href="#a89e8eecec4bae12a4018228fbb94ff1c">More...</a><br/></td></tr>
<tr class="separator:a89e8eecec4bae12a4018228fbb94ff1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c840ad4473c74959ed396773b98e3b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a2c840ad4473c74959ed396773b98e3b9">can_castle_bking</a> ()</td></tr>
<tr class="memdesc:a2c840ad4473c74959ed396773b98e3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">can_castle_bking see can_castle_wking  <a href="#a2c840ad4473c74959ed396773b98e3b9">More...</a><br/></td></tr>
<tr class="separator:a2c840ad4473c74959ed396773b98e3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad233634a43bcaee9ef7490563e119500"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#ad233634a43bcaee9ef7490563e119500">can_castle_wqueen</a> ()</td></tr>
<tr class="memdesc:ad233634a43bcaee9ef7490563e119500"><td class="mdescLeft">&#160;</td><td class="mdescRight">can_castle_wqueen see can_castle_wking  <a href="#ad233634a43bcaee9ef7490563e119500">More...</a><br/></td></tr>
<tr class="separator:ad233634a43bcaee9ef7490563e119500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c869f01bdb5dbedbe1247a7ef6e081"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a08c869f01bdb5dbedbe1247a7ef6e081">can_castle_bqueen</a> ()</td></tr>
<tr class="memdesc:a08c869f01bdb5dbedbe1247a7ef6e081"><td class="mdescLeft">&#160;</td><td class="mdescRight">can_castle_bqueen see can_castle_wking  <a href="#a08c869f01bdb5dbedbe1247a7ef6e081">More...</a><br/></td></tr>
<tr class="separator:a08c869f01bdb5dbedbe1247a7ef6e081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c19f4ee4fed148786b1215790f62a0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a0c19f4ee4fed148786b1215790f62a0e">is_undo_available</a> ()</td></tr>
<tr class="memdesc:a0c19f4ee4fed148786b1215790f62a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_undo_available checks whether the current board position has enough information to apply the <a class="el" href="classchess_1_1Board.html#afbd72bf71259ba08016f6b547075d19b" title="undo undoes the very last move. undoing can only be done once for the very last move that was applied...">undo()</a> operation, i.e. take back the last move and return to the previous board state.  <a href="#a0c19f4ee4fed148786b1215790f62a0e">More...</a><br/></td></tr>
<tr class="separator:a0c19f4ee4fed148786b1215790f62a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9caaf507db0ebca5530dfbeaa1de4d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#af9caaf507db0ebca5530dfbeaa1de4d1">set_castle_wking</a> (bool can_do)</td></tr>
<tr class="memdesc:af9caaf507db0ebca5530dfbeaa1de4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">set_castle_wking set/unset the right of the white king to castle kingside.  <a href="#af9caaf507db0ebca5530dfbeaa1de4d1">More...</a><br/></td></tr>
<tr class="separator:af9caaf507db0ebca5530dfbeaa1de4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b44c135a8d202fba74d0420bfbb1ece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a3b44c135a8d202fba74d0420bfbb1ece">set_castle_bking</a> (bool can_do)</td></tr>
<tr class="memdesc:a3b44c135a8d202fba74d0420bfbb1ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">set_castle_bking see set_castle_wking  <a href="#a3b44c135a8d202fba74d0420bfbb1ece">More...</a><br/></td></tr>
<tr class="separator:a3b44c135a8d202fba74d0420bfbb1ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1a6532bae11d8c2b1e54786082243a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#aea1a6532bae11d8c2b1e54786082243a">set_castle_wqueen</a> (bool can_do)</td></tr>
<tr class="memdesc:aea1a6532bae11d8c2b1e54786082243a"><td class="mdescLeft">&#160;</td><td class="mdescRight">set_castle_wqueen see set_castle_wking  <a href="#aea1a6532bae11d8c2b1e54786082243a">More...</a><br/></td></tr>
<tr class="separator:aea1a6532bae11d8c2b1e54786082243a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb70e7236fa809317a98453a2195c336"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#abb70e7236fa809317a98453a2195c336">set_castle_bqueen</a> (bool can_do)</td></tr>
<tr class="memdesc:abb70e7236fa809317a98453a2195c336"><td class="mdescLeft">&#160;</td><td class="mdescRight">set_castle_bqueen see set_castle_wking  <a href="#abb70e7236fa809317a98453a2195c336">More...</a><br/></td></tr>
<tr class="separator:abb70e7236fa809317a98453a2195c336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b86c20aa1698b9418e95517da36f49a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a8b86c20aa1698b9418e95517da36f49a">set_piece_at</a> (int x, int y, uint8_t piece)</td></tr>
<tr class="memdesc:a8b86c20aa1698b9418e95517da36f49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">set_piece_at sets a piece a the supplied board position (x,y)  <a href="#a8b86c20aa1698b9418e95517da36f49a">More...</a><br/></td></tr>
<tr class="separator:a8b86c20aa1698b9418e95517da36f49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ee306cf1bed5aa97c99b90fa2462e9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a11ee306cf1bed5aa97c99b90fa2462e9">get_piece_at</a> (int x, int y)</td></tr>
<tr class="memdesc:a11ee306cf1bed5aa97c99b90fa2462e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_piece_at gets piece a the supplied board position (x,y)  <a href="#a11ee306cf1bed5aa97c99b90fa2462e9">More...</a><br/></td></tr>
<tr class="separator:a11ee306cf1bed5aa97c99b90fa2462e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335cf36085d8de6a2ad784f12fa3ea87"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a335cf36085d8de6a2ad784f12fa3ea87">get_piece_type_at</a> (int x, int y)</td></tr>
<tr class="memdesc:a335cf36085d8de6a2ad784f12fa3ea87"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_piece_type_at get the piece type as uint8_t at supplied position. piece type is always the piece encoded as if it were are white piece (see KING, QUEEN, or empty).  <a href="#a335cf36085d8de6a2ad784f12fa3ea87">More...</a><br/></td></tr>
<tr class="separator:a335cf36085d8de6a2ad784f12fa3ea87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc8ee041129aee3d29d8dca68379f5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a0cc8ee041129aee3d29d8dca68379f5e">get_piece_color_at</a> (int x, int y)</td></tr>
<tr class="memdesc:a0cc8ee041129aee3d29d8dca68379f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_piece_color_at returns color (i.e. WHITE or BLACK) at supplied position. Don't call if there is is no piece at the position! (check with piece_type first)  <a href="#a0cc8ee041129aee3d29d8dca68379f5e">More...</a><br/></td></tr>
<tr class="separator:a0cc8ee041129aee3d29d8dca68379f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8cad6d67c80c279fb79d6438571c31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a8b8cad6d67c80c279fb79d6438571c31">piece_color</a> (uint8_t idx)</td></tr>
<tr class="memdesc:a8b8cad6d67c80c279fb79d6438571c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">piece_color same as get_piece_color_at but uses here the internal position encoding to specify the field of the board. see this header file  <a href="#a8b8cad6d67c80c279fb79d6438571c31">More...</a><br/></td></tr>
<tr class="separator:a8b8cad6d67c80c279fb79d6438571c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d50dca97ed1da2254f37d6635eb8af"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a72d50dca97ed1da2254f37d6635eb8af">piece_type</a> (uint8_t idx)</td></tr>
<tr class="memdesc:a72d50dca97ed1da2254f37d6635eb8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">piece_type see piece_color and <a class="el" href="classchess_1_1Board.html#a335cf36085d8de6a2ad784f12fa3ea87" title="get_piece_type_at get the piece type as uint8_t at supplied position. piece type is always the piece ...">get_piece_type_at()</a>  <a href="#a72d50dca97ed1da2254f37d6635eb8af">More...</a><br/></td></tr>
<tr class="separator:a72d50dca97ed1da2254f37d6635eb8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56972d814d398cdcb152b09aa4156965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a56972d814d398cdcb152b09aa4156965">is_consistent</a> ()</td></tr>
<tr class="memdesc:a56972d814d398cdcb152b09aa4156965"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_consistent rudimentary check of position consistency  <a href="#a56972d814d398cdcb152b09aa4156965">More...</a><br/></td></tr>
<tr class="separator:a56972d814d398cdcb152b09aa4156965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4dcba09aa3863ad90bb170d7d928be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a4d4dcba09aa3863ad90bb170d7d928be">is_black_king_castle_right_lost</a> ()</td></tr>
<tr class="memdesc:a4d4dcba09aa3863ad90bb170d7d928be"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_black_king_castle_right_lost does not return castling rights of current position (for that call <a class="el" href="classchess_1_1Board.html#a2c840ad4473c74959ed396773b98e3b9" title="can_castle_bking see can_castle_wking ">can_castle_bking()</a> etc. ) instead checks whether black king and rook are in initial position or have moved  <a href="#a4d4dcba09aa3863ad90bb170d7d928be">More...</a><br/></td></tr>
<tr class="separator:a4d4dcba09aa3863ad90bb170d7d928be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92f5282b668129747f57993528f4e0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#ac92f5282b668129747f57993528f4e0a">is_black_queen_castle_right_lost</a> ()</td></tr>
<tr class="memdesc:ac92f5282b668129747f57993528f4e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_black_queen_castle_right_lost see <a class="el" href="classchess_1_1Board.html#a4d4dcba09aa3863ad90bb170d7d928be" title="is_black_king_castle_right_lost does not return castling rights of current position (for that call ca...">is_black_king_castle_right_lost()</a>  <a href="#ac92f5282b668129747f57993528f4e0a">More...</a><br/></td></tr>
<tr class="separator:ac92f5282b668129747f57993528f4e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a959761717852a29b9d07964146c28e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a9a959761717852a29b9d07964146c28e">is_white_king_castle_right_lost</a> ()</td></tr>
<tr class="memdesc:a9a959761717852a29b9d07964146c28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_white_king_castle_right_lost see <a class="el" href="classchess_1_1Board.html#a4d4dcba09aa3863ad90bb170d7d928be" title="is_black_king_castle_right_lost does not return castling rights of current position (for that call ca...">is_black_king_castle_right_lost()</a>  <a href="#a9a959761717852a29b9d07964146c28e">More...</a><br/></td></tr>
<tr class="separator:a9a959761717852a29b9d07964146c28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872cf3888b3b7456f0f641d10a614e5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a872cf3888b3b7456f0f641d10a614e5c">is_white_queen_castle_right_lost</a> ()</td></tr>
<tr class="memdesc:a872cf3888b3b7456f0f641d10a614e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_white_queen_castle_right_lost see <a class="el" href="classchess_1_1Board.html#a4d4dcba09aa3863ad90bb170d7d928be" title="is_black_king_castle_right_lost does not return castling rights of current position (for that call ca...">is_black_king_castle_right_lost()</a>  <a href="#a872cf3888b3b7456f0f641d10a614e5c">More...</a><br/></td></tr>
<tr class="separator:a872cf3888b3b7456f0f641d10a614e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a1726413a7710da68c1d87c190d59ff2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1726413a7710da68c1d87c190d59ff2d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a1726413a7710da68c1d87c190d59ff2d">turn</a></td></tr>
<tr class="memdesc:a1726413a7710da68c1d87c190d59ff2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">turn is either == WHITE or == BLACK <br/></td></tr>
<tr class="separator:a1726413a7710da68c1d87c190d59ff2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5560fe97c8de0895aad63a16f2fe989d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5560fe97c8de0895aad63a16f2fe989d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a5560fe97c8de0895aad63a16f2fe989d">halfmove_clock</a></td></tr>
<tr class="memdesc:a5560fe97c8de0895aad63a16f2fe989d"><td class="mdescLeft">&#160;</td><td class="mdescRight">halfmove_clock number of halfmoves from beginning. automatically updated after applying a move <br/></td></tr>
<tr class="separator:a5560fe97c8de0895aad63a16f2fe989d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e62bd7f7c8a08a06f60b0a5c4d9f0f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e62bd7f7c8a08a06f60b0a5c4d9f0f9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a2e62bd7f7c8a08a06f60b0a5c4d9f0f9">fullmove_number</a></td></tr>
<tr class="memdesc:a2e62bd7f7c8a08a06f60b0a5c4d9f0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">fullmove_number <br/></td></tr>
<tr class="separator:a2e62bd7f7c8a08a06f60b0a5c4d9f0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab804a92f19458640a977ec4a713e4f7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab804a92f19458640a977ec4a713e4f7b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#ab804a92f19458640a977ec4a713e4f7b">last_was_null</a></td></tr>
<tr class="memdesc:ab804a92f19458640a977ec4a713e4f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">last_was_null set to true, if last the last move leading to this board position was a null move <br/></td></tr>
<tr class="separator:ab804a92f19458640a977ec4a713e4f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a12c9a3f04eea162630a1cffdb8560667"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchess_1_1Board.html#a12c9a3f04eea162630a1cffdb8560667">operator&lt;&lt;</a> (std::ostream &amp;strm, const <a class="el" href="classchess_1_1Board.html">Board</a> &amp;b)</td></tr>
<tr class="memdesc:a12c9a3f04eea162630a1cffdb8560667"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator &lt;&lt;  <a href="#a12c9a3f04eea162630a1cffdb8560667">More...</a><br/></td></tr>
<tr class="separator:a12c9a3f04eea162630a1cffdb8560667"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af172f8f4202f976b9e08a602f7f7e104"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">chess::Board::Board </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial_position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classchess_1_1Board.html">Board</a> creates board w/ initial position, castling rights set if called with true creates empty board board, no castling rights if called with false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_position</td><td>triggers wether initial position or empty should be created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a147c213c864ad018056ca446e2de46b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">chess::Board::Board </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>fen_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classchess_1_1Board.html">Board</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fen_string</td><td>creates board from FEN string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98009c374d8ca3778124a2618ef1b36b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">chess::Board::Board </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchess_1_1Board.html">Board</a> *&#160;</td>
          <td class="paramname"><em>board</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classchess_1_1Board.html">Board</a> creates new <a class="el" href="classchess_1_1Board.html">Board</a> copying position of the pieces of the supplied board. Parameters (i.e. undo history, move numbers etc. are <em>not</em> copied, just the position of the pieces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">board</td><td>The board where the position of pieces is taken from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5d17441690ffdf9a1000309e2272f6de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Board::apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchess_1_1Move.html">Move</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply applies supplied move. doesn't check for legality no check of legality. always call board.is_legal(m) before applying move </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>move to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c840ad4473c74959ed396773b98e3b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::can_castle_bking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>can_castle_bking see can_castle_wking </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a08c869f01bdb5dbedbe1247a7ef6e081"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::can_castle_bqueen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>can_castle_bqueen see can_castle_wking </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a89e8eecec4bae12a4018228fbb94ff1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::can_castle_wking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>can_castle_wking checks whether the castling rights for the position are such that the White king is allowed to castle kingside in this position. </p>
<dl class="section return"><dt>Returns</dt><dd>true if king may castle, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad233634a43bcaee9ef7490563e119500"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::can_castle_wqueen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>can_castle_wqueen see can_castle_wking </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="afff07e23bb49d912617caf276323443e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchess_1_1Board.html">Board</a> * chess::Board::copy_and_apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchess_1_1Move.html">Move</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy_and_apply applies move and returns a deep copy of current board no check of legality. always call board.is_legal(m) before applying move </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>move to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of board </dd></dl>

</div>
</div>
<a class="anchor" id="acf162aeb9ab6abbb3e4d6a868e3a07e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString chess::Board::fen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fen returns FEN string of current board </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a11ee306cf1bed5aa97c99b90fa2462e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chess::Board::get_piece_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get_piece_at gets piece a the supplied board position (x,y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>int in the range (0,7) representing the column (i.e. a - h) </td></tr>
    <tr><td class="paramname">y</td><td>int in the range (0,7) representing the row (i.e. 0 - 7) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>piece type encoded as uint8_t (i.e. BLACK_QUEEN or EMPTY) </dd></dl>

</div>
</div>
<a class="anchor" id="a0cc8ee041129aee3d29d8dca68379f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::get_piece_color_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get_piece_color_at returns color (i.e. WHITE or BLACK) at supplied position. Don't call if there is is no piece at the position! (check with piece_type first) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>column </td></tr>
    <tr><td class="paramname">y</td><td>row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>piece color </dd></dl>

</div>
</div>
<a class="anchor" id="a335cf36085d8de6a2ad784f12fa3ea87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chess::Board::get_piece_type_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get_piece_type_at get the piece type as uint8_t at supplied position. piece type is always the piece encoded as if it were are white piece (see KING, QUEEN, or empty). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>int in the range (0,7) representing the column (i.e. a - h) </td></tr>
    <tr><td class="paramname">y</td><td>int in the range (0,7) representing the column (i.e. a - h) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>piece encoding </dd></dl>

</div>
</div>
<a class="anchor" id="a4d4dcba09aa3863ad90bb170d7d928be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::is_black_king_castle_right_lost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is_black_king_castle_right_lost does not return castling rights of current position (for that call <a class="el" href="classchess_1_1Board.html#a2c840ad4473c74959ed396773b98e3b9" title="can_castle_bking see can_castle_wking ">can_castle_bking()</a> etc. ) instead checks whether black king and rook are in initial position or have moved </p>
<p>Board::is_black_castle_right_lost.</p>
<dl class="section return"><dt>Returns</dt><dd>false, if black king or rook have moved from inital pos, true otherwise.</dd>
<dd>
true if black king and kingside rook are on initial position, false otherwise i.e. checks the <em>possibility</em> whether castling could be possible (to check consistency when entering a board position) to call board status, use can_castle_* functions </dd></dl>

</div>
</div>
<a class="anchor" id="ac92f5282b668129747f57993528f4e0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::is_black_queen_castle_right_lost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is_black_queen_castle_right_lost see <a class="el" href="classchess_1_1Board.html#a4d4dcba09aa3863ad90bb170d7d928be" title="is_black_king_castle_right_lost does not return castling rights of current position (for that call ca...">is_black_king_castle_right_lost()</a> </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="af12b1804d1edf018dbb348055cf88025"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::is_check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is_check checks if the player whose on the move in the current position is in check </p>
<dl class="section return"><dt>Returns</dt><dd>true, if player in check, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a24673c511d27445702013a7569f7291b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::is_checkmate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is_checkmate tests whether player who is on the move in current position is in checkmate (i.e. is in check but has not legal move escaping the check) </p>
<dl class="section return"><dt>Returns</dt><dd>true, if player in checkmate, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a56972d814d398cdcb152b09aa4156965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::is_consistent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is_consistent rudimentary check of position consistency </p>
<dl class="section return"><dt>Returns</dt><dd>true if the conditions below are true, false otherwise</dd></dl>
<p>NOTE: this doesn't capture <em>all</em> invalid positions, but the most common reasons there exists one white and one black king [ok] kings are &gt;= 1 field apart [ok] side not to move is not in check [ok] side to move has less than three attackers who give check if side to move is in check w/ two attackers: following must not hold: pawn+(pawn, bishop, knight), bishop+bishop, knight+knight each side has less than 8 pawns [ok] no pawns in first or last row [ok] extra pieces = Math.max(0, num_queens-1) + Math.max(0, num_rooks-2)... and extra_pieces &lt;= (8-num_pawns)) no more than 5 pawns in a or h line checks consistency of castling rights. if set, then verify w/ is_black_castle_right_lost() and is_white_castle_lost() </p>

</div>
</div>
<a class="anchor" id="af20f52e22fd1f61458f523eb6c1e9c7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::is_initial_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is_initial_position checks whether the current placement of the pieces corresponds to the inital chess position. </p>
<dl class="section return"><dt>Returns</dt><dd>true if initial position, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae338726c0c954644b99342c9760d5924"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::is_legal_and_promotes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchess_1_1Move.html">Move</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is_legal_and_promotes checks whether supplied move is legal and is a pawn move promoting to another piece </p>
<dl class="section return"><dt>Returns</dt><dd>true only if both move is legal and pawn move and promotes. false, otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acd8243ca7cdd3fa72f07aa5f225a750a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::is_legal_move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchess_1_1Move.html">Move</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is_legal_move checks whether the supplied move is legal in the board position. Always call before applying a move on a board! </p>
<dl class="section return"><dt>Returns</dt><dd>true, if the move is legal, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a7ff751702f53df82a8af55d66f187f66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::is_stalemate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is_stalemate tests whether player who is on the move in current position is in stalemate (i.e. is not in check but all legal moves would result in check) </p>
<dl class="section return"><dt>Returns</dt><dd>true, if position is stalemate, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c19f4ee4fed148786b1215790f62a0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::is_undo_available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is_undo_available checks whether the current board position has enough information to apply the <a class="el" href="classchess_1_1Board.html#afbd72bf71259ba08016f6b547075d19b" title="undo undoes the very last move. undoing can only be done once for the very last move that was applied...">undo()</a> operation, i.e. take back the last move and return to the previous board state. </p>
<dl class="section return"><dt>Returns</dt><dd>true if info is available (i.e. <a class="el" href="classchess_1_1Board.html#afbd72bf71259ba08016f6b547075d19b" title="undo undoes the very last move. undoing can only be done once for the very last move that was applied...">undo()</a> may be called), false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a9a959761717852a29b9d07964146c28e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::is_white_king_castle_right_lost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is_white_king_castle_right_lost see <a class="el" href="classchess_1_1Board.html#a4d4dcba09aa3863ad90bb170d7d928be" title="is_black_king_castle_right_lost does not return castling rights of current position (for that call ca...">is_black_king_castle_right_lost()</a> </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a872cf3888b3b7456f0f641d10a614e5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::is_white_queen_castle_right_lost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is_white_queen_castle_right_lost see <a class="el" href="classchess_1_1Board.html#a4d4dcba09aa3863ad90bb170d7d928be" title="is_black_king_castle_right_lost does not return castling rights of current position (for that call ca...">is_black_king_castle_right_lost()</a> </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="af33abea2f6fba7df0e683fa1198a8520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Moves * chess::Board::legal_moves </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>legal_moves returns move list of all legal moves in position </p>
<dl class="section return"><dt>Returns</dt><dd>move list </dd></dl>

</div>
</div>
<a class="anchor" id="a354b83ee53ba1f0ff7a7d0bac148d758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Moves * chess::Board::legal_moves_from </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from_square</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>legal_moves_from computes all legal moves originating in from square </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_square</td><td>move originates from this square. must be in range 21...98 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>move list of legal moves </dd></dl>

</div>
</div>
<a class="anchor" id="a422f4f975a7946ad593e870aa46cec89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::movePromotes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchess_1_1Move.html">Move</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>movePromotes checks if the supplied move (ignoring the promotion value stored in the move is a pawn move to the 8th / 1st rank, i.e. promoting) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>move of concern </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if move promotes, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a872aeef9bac835b88393092229685410"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchess_1_1Move.html">Move</a> chess::Board::parse_san </td>
          <td>(</td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parse_san Given board position and san string, parses the san string and computes a move for it. Throws std::invalid_argument if the supplied san string cannot be parsed successfully (i.e. illegal move, illegal formatted string etc.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string containing a san representation of a move (no move number!) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>move object (if parsed successfully) </dd></dl>

</div>
</div>
<a class="anchor" id="a8b8cad6d67c80c279fb79d6438571c31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::piece_color </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>piece_color same as get_piece_color_at but uses here the internal position encoding to specify the field of the board. see this header file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>internal board encoding specifying field position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>piece color </dd></dl>

</div>
</div>
<a class="anchor" id="a72d50dca97ed1da2254f37d6635eb8af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chess::Board::piece_type </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>piece_type see piece_color and <a class="el" href="classchess_1_1Board.html#a335cf36085d8de6a2ad784f12fa3ea87" title="get_piece_type_at get the piece type as uint8_t at supplied position. piece type is always the piece ...">get_piece_type_at()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a804f9b6cceeef5f3f5d866d16e1097a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chess::Board::pseudo_is_legal_move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchess_1_1Move.html">Move</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pseudo_is_legal_move checks whether supplied pseudo legal move is legal in current position. Does NOT check whether supplied move is pseudo legal!!! </p>
<dl class="section return"><dt>Returns</dt><dd>result of checking legality </dd></dl>

</div>
</div>
<a class="anchor" id="ac9aa7f45517551baa208ed49ede59d97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Moves * chess::Board::pseudo_legal_moves </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pseudo_legal_moves returns move list with all pseudo-legal moves of current position </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a9d573f32784dd7744640a5709c44de50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Moves * chess::Board::pseudo_legal_moves_from </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from_square_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_castles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>turn_color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pseudo_legal_moves_from returns move list with pseudo legal moves from supplied square index </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_square_idx</td><td>square from which move originates must be in internal board representation, i.e. in range 21 ... 98 </td></tr>
    <tr><td class="paramname">with_castles</td><td>include castling in returned list </td></tr>
    <tr><td class="paramname">turn_color</td><td>either WHITE or BLACK, i.e. the player to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pseudo legal move list </dd></dl>

</div>
</div>
<a class="anchor" id="a2c498a11b0432a8c41a9dcece41612b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString chess::Board::san </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchess_1_1Move.html">Move</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>san computes the standard algebraic notation for the supplied move given the current position. the supplied move MUST be legal on this board </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td><a class="el" href="classchess_1_1Move.html">Move</a> to get the san for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string containing san representation of move (no move number!) </dd></dl>

</div>
</div>
<a class="anchor" id="a3b44c135a8d202fba74d0420bfbb1ece"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Board::set_castle_bking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>can_do</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set_castle_bking see set_castle_wking </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">can_do</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb70e7236fa809317a98453a2195c336"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Board::set_castle_bqueen </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>can_do</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set_castle_bqueen see set_castle_wking </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">can_do</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9caaf507db0ebca5530dfbeaa1de4d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Board::set_castle_wking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>can_do</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set_castle_wking set/unset the right of the white king to castle kingside. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">can_do</td><td>true to allow white to castle, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea1a6532bae11d8c2b1e54786082243a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Board::set_castle_wqueen </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>can_do</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set_castle_wqueen see set_castle_wking </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">can_do</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b86c20aa1698b9418e95517da36f49a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chess::Board::set_piece_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>piece</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set_piece_at sets a piece a the supplied board position (x,y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>int in the range (0,7) representing the column (i.e. a - h) </td></tr>
    <tr><td class="paramname">y</td><td>int in the range (0,7) representing the row (i.e. 0 - 7) </td></tr>
    <tr><td class="paramname">piece</td><td>the piece type (constants such as WHITE_KING, BLACK_QUEEN, EMPTY etc.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a12c9a3f04eea162630a1cffdb8560667"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchess_1_1Board.html">Board</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator &lt;&lt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>prints board as ascii output.</p>
<p>Example: <a class="el" href="classchess_1_1Board.html">Board</a> b(); std::cout &lt;&lt; b &lt;&lt; std::endl; </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>chess/<a class="el" href="board_8h_source.html">board.h</a></li>
<li>chess/board.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat May 21 2016 22:33:28 for Jerry - Chess GUI by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
